{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"A%20Crash%20Course%20in%20DNS%20%28Domain%20Name%20System%29/","text":"What if you woke up tomorrow and could no longer access websites by typing names like google.com or espn.com? Instead, you had to memorize and type a series of numbers just to get online - 172.217.16.206 to check Gmail or 199.181.132.250 to read sports news. Internet browsing would become extremely tedious overnight! Luckily, this internet nightmare scenario will never happen as long as DNS keeps running smoothly in the background. DNS, short for Domain Name System, is the essential service that saves us from the huge hassle of memorizing numeric IP addresses. It efficiently matches easy-to-remember domain names with their corresponding IP addresses so we can browse seamlessly. In this article, we explore the intricate workings of this crucial internet backbone. DNS: The Internet\u2019s Address Book DNS is a distributed and hierarchical system that acts as the internet's address book. It translates domain names into IP addresses to facilitate efficient communication between devices across the globe. The primary purpose of DNS is to provide a convenient way for users to access websites and resources using easily memorable domain names, while computers and servers use IP addresses for communication behind the scenes. The DNS is implemented as an Application layer service. It is implemented by the servers that sit at the network edge rather than routers and switches inside the network. This reflects the internet design philosophy of keeping the network core simple and putting complexity at the network\u2019s edge. Key Services Provided by DNS DNS provides a number of different services to facilitate the functioning of the Internet. Here is a mind map of the services provided by DNS. We are going to describe some of the most vital services of DNS below: Host-to-IP address mapping DNS maintains a database of domain names and their corresponding IP addresses. This mapping is essential for devices to locate each other on the internet. For instance, consider the domain name \"www.bytebytego.com.\" Host-to-IP address mapping involves determining the IP address associated with this domain, such as \"172.67.21.11\". Host aliasing DNS supports a feature commonly known as host aliasing, enabled through CNAME (Canonical Name) records. This allows a single IP address or primary domain name to be associated with multiple domain name aliases. For example, let's consider the primary domain \"bytebytego.com\". You might want your website to be accessible not just via \"bytebytego.com\", but also through various aliases like \"www.bytebytego.com\", \"web.bytebytego.com\", and \"blog.bytebytego.com\". By setting up appropriate CNAME records in DNS, all these aliases can point to the primary domain \"bytebytego.com\". As a result, users can access your website using any of these domain names, all leading to the same destination IP address. Email Routing DNS plays a crucial role in email routing through MX records. These records allow a domain to specify which mail servers are responsible for receiving email messages on its behalf. This mechanism enables flexibility in email configurations. For example, let's say the primary mail server designated to receive emails for the \"bytebytego.com\" domain is \"mail.bytebytego.com\". You might want to have specific email addresses, such as those ending in \"@sales.bytebytego.com\" or \"@support.bytebytego.com\", yet still direct all incoming mail for these addresses to the \"mail.bytebytego.com\" server. By configuring MX records appropriately, emails sent to any of these addresses will route to the designated primary mail server. IP-to-host address mapping While DNS is primarily used for translating domain names to IP addresses, it can also perform reverse lookups, translating IP addresses back to domain names. This is useful for security and logging purposes. Load balancing DNS can distribute incoming network traffic across multiple servers by returning different IP addresses in response to the same domain name query. This helps balance the load and improve the performance and reliability of online services. DNS Hierarchy DNS operates as a distributed hierarchical database. The following illustration shows a high-level view of the DNS hierarchy. [ ](https://substackcdn.com/image/fetch/$s_!P_Ol!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff0a1bb2c-a1bc-40ce-abde-6fb9d2a66ce8_1600x570.png) Root DNS Servers At the top of the DNS hierarchy are the root servers. The root servers are contacted when a server is not actually able to resolve a name. You can think of it as a first point of contact to get the resolution started. Root servers act like the central nervous system of the internet, and as such, security is going to be very important. Much of the infrastructure associated with the root servers is the responsibility of ICANN (Internet Corporation for Assigned Names and Numbers). There are 13 logical root servers around the world, but each of these logical root servers is actually replicated, so corresponding to these 13 logical servers are actually close to a thousand physical servers around the world. Top-Level Domain (TLD) DNS servers Moving down a level from the root servers, we find the TLD (Top-Level Domain) servers and each of the servers in the TLD layer is responsible for resolving one of the addresses that have an ending like .com , .edu , .net , and .org . The Internet Corporation for Assigned Names and Numbers (ICANN) has authority over all TLDs used on the Internet, and it delegates the responsibility of these TLDs to various organizations. For individuals or entities looking to register a new domain under these TLDs, they typically approach Domain Name Registrars, which are accredited entities interfacing with the registries to handle the registration process. Authoritative DNS servers Authoritative servers are the definitive source for domain name resolutions within their specific domain. They store the actual name-to-IP address mappings for a given domain. While various caching mechanisms exist across the internet to speed up domain name resolutions, it's the authoritative servers that provide the correct and final answer when queried. Domain owners or administrators configure their domain's records, but the actual infrastructure\u2014the DNS servers\u2014is often maintained and operated by DNS hosting providers or registrars like Cloudflare, Namecheap, GoDaddy, and others. Recursive DNS Servers (Resolver) Recursive servers handle DNS queries from client devices like computers and smartphones. When a device wants to resolve a domain name, it contacts these servers. Acting on behalf of the client, recursive servers traverse the DNS hierarchy, consulting various DNS servers to determine the IP address associated with a domain name. Once they obtain the answer, they return it to the client. For efficiency, recursive servers often cache responses to avoid repeatedly querying the same information. Check out the illustration below, it shows the placement of some of the main DNS servers inside the pipeline of a DNS query. [ ](https://substackcdn.com/image/fetch/$s_!2I4b!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F99472ff8-82a1-4365-bb03-c9a00b39e412_1419x336.png) How DNS Resolution Works There are two main methods of query resolution in DNS: Iterative query resolution Recursive query resolution These methods define how DNS servers interact with each other to find the IP address associated with a given domain name. Here\u2019s a brief overview of each method. Iterative Query Resolution In iterative query resolution, the DNS server receiving the query provides referrals to the querying server, guiding it through the DNS hierarchy. The querying server actively participates in the process by sending subsequent queries based on the referrals received. Let's try to understand the workings of iterative query resolution with the help of an example shown in the illustration below. [ ](https://substackcdn.com/image/fetch/$s_!eaJb!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F96fbf5fc-bf5d-4047-b058-f48f6f3b3a30_1600x1432.png) Suppose the requesting host is making a request to resolve the name bytebytego.com . Here\u2019s how this is going to unfold: The host first sends a query message to the local DNS resolver. The query message contains the hostname to be translated bytebytego.com If the resolver doesn't have the IP address in its cache, it sends a query to a root DNS server. The root DNS server, recognizing the .com suffix, provides a referral to TLD servers responsible for .com The resolver then sends a new query to one of these TLD servers. The TLD server provides a referral to the authoritative DNS server responsible for bytebytego.com . The resolver sends another query to the authoritative DNS server. The authoritative DNS server responds with the IP address of bytebytego.com The DNS resolver caches this IP address and then returns it to the requesting host. Now, the requesting host makes an HTTP request to the IP address of the http://www.bytebytego.com web server. The web server returns the webpage for www.bytebytego.com Recursive Query Resolution In recursive query resolution, the DNS server receiving the query takes on the responsibility of finding the IP address on behalf of the client. It may itself use iterative queries to navigate through the DNS hierarchy until it reaches the authoritative DNS server for the requested domain. Let\u2019s use the previous example and try to resolve the IP address of bytebytego.com using the recursive query resolution as shown in the illustration below: [ ](https://substackcdn.com/image/fetch/$s_!ZguZ!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F23550856-e23b-4372-8422-20630dfea888_1600x1432.png) We have summarized the steps shown in the above illustration as follows: The client sends a query to the local DNS resolver. The resolver checks its cache for the IP address. If not found, it conducts the necessary queries\u2014possibly iterative ones\u2014interacting with root DNS servers, then TLD DNS servers, and finally authoritative DNS servers until it obtains the IP address. Once found, the resolver caches the IP address and returns it to the client. Subsequent queries for the same domain can be answered directly from the resolver's cache. Both iterative and recursive query resolution methods are vital to the functioning of the DNS. Recursive queries simplify the process for clients, with the resolver managing the hierarchical queries and caching. Iterative queries involve the querying server actively following referrals to find the IP address. Note : In practice, most client devices send queries to recursive DNS resolvers, which often use a mix of recursive and iterative queries behind the scenes to fetch and cache results, ensuring efficient operation of the global DNS system. Caching in DNS DNS resolution involves several steps, and to expedite repeated resolutions of the same domain names, the system leverages caching. Caching recently resolved DNS query results can drastically reduce the number of repeated queries to authoritative DNS servers. By caching DNS records, the efficiency and speed of DNS resolution is significantly improved. It reduces the need for recursive servers to navigate the entire DNS hierarchy every time a domain is queried. Where does DNS caching occur? DNS records are cached at various points in the resolution process. The duration for which a record is cached is determined by its time-to-live (TTL) value. At the local machine : Devices like computers and smartphones have local DNS caches. When you visit a website, your device's DNS resolver stores the resolved IP address along with the associated domain name in its cache. This way, if you visit the same website again or access resources on the same domain, the DNS resolution process is faster. At the recursive DNS server : Recursive DNS servers, often maintained by ISPs and other organizations, cache DNS records. This benefits multiple users within the same network accessing the same domain, as the cached record can be provided without querying the entire DNS hierarchy again. At the authoritative DNS server : While it might seem counterintuitive, even authoritative DNS servers (which hold the official domain records) use caching. This helps in efficiently handling high query volumes and reduces redundant processing. Note : Cached DNS records can become outdated if the original record changes. However, outdated cache entries are not a major concern in the DNS system. They will be automatically removed when their TTL expires. DNS propagation After registering or updating a domain, there might be a delay before the domain is accessible universally. This delay is called DNS Propagation. Let\u2019s try to understand this concept with the help of an example. Imagine you've registered a domain, mywebsite.com, with GoDaddy, a popular domain registrar. If you try to access this domain immediately after registration, you might encounter issues. [ ](https://substackcdn.com/image/fetch/$s_!FTpt!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fcdca2ea4-1490-443c-9883-e431c1394bc3_1600x555.png) Despite updating the record at the authoritative server, many recursive DNS servers and local caches around the world might still have the old (or non-existent) record cached. Until these cached records expire (as per their TTL) and are replaced with the updated record, users might face access issues. This period of inconsistency, where different parts of the world might see different records, is DNS Propagation. Typically, most DNS propagations complete within 24-48 hours, but the commonly cited upper limit is 72 hours. However, it's essential to set reasonable TTL values to ensure rapid propagation when changes are made. DNS Resource Records (RRs) Now, let\u2019s talk about how data is being stored in DNS databases. Data in DNS is stored in the form of Resource Records (RRs). When a device queries a DNS server about a domain name, the server provides the relevant RRs, helping the device access the desired resource on the internet. Here is the structure of a DNS resource record: [ ](https://substackcdn.com/image/fetch/$s_!-tUg!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff3c5ba97-c19c-4a0c-9b0f-128f9f5413f9_1188x489.png) Most of the fields in the RR are self-explanatory. However, we would like to discuss the Type field in more detail. There are different types of DNS resource records, but here we discuss four common RR types in DNS: Type A record (Address record): Maps a domain name to an IPv4 address. It's used to translate human-readable domain names into numerical IP addresses as shown below. Type NS record (Name Server record): Specifies the authoritative name servers for a domain. These name servers hold the official DNS records for the domain. Type CNAME record (Canonical Name record): Creates an alias for a domain name, pointing it to another domain's canonical (real) name. Type MX record (Mail Exchange record): Specifies the mail servers responsible for receiving email messages for a domain. The below illustration shows these four types when used in a DNS query and their corresponding DNS responses. [ ](https://substackcdn.com/image/fetch/$s_!MUtQ!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F887873eb-a776-44b4-84b4-2485ea590992_1600x1406.png) Dynamic DNS An essential extension of DNS is the Dynamic DNS (DDNS). This service allows users to automatically update the mapping between domain names and IP addresses whenever the IP address changes. The primary use-case for Dynamic DNS is to support hosts that have dynamic IP addresses, like those assigned by many residential ISPs. DDNS is invaluable for individuals and small businesses wanting to host services, websites, or devices on networks with dynamic IP addresses. It ensures consistent remote access by providing a stable domain name that always points to the current IP address, even if that address changes frequently. DNS and Anycast Anycast is a network addressing and routing methodology where multiple servers share the same IP address. When a client sends a request to an Anycast IP address, the network determines the closest server (in terms of routing efficiency) to serve that request. Using Anycast in DNS provides benefits such as faster response times due to reduced latency, better load distribution among servers, and enhanced redundancy. If one server fails, the network automatically reroutes requests to another available server. Many TLD name servers and major DNS service providers leverage Anycast to improve the performance, reliability, and resilience of their services. DNS Security Now that you understand what the DNS does, you can see how absolutely critical it is to the functioning of the internet. If the DNS stopped working, it\u2019d be impossible to contact any host unless you knew its IP address, which means practically never. So it's critical the DNS be protected. Below, we discuss some of the most popular security protocols to protect DNS: DNSSEC Domain Name System Security Extensions (DNSSEC) is a set of extensions to DNS that adds an additional layer of security by digitally signing DNS data. It helps in ensuring the authenticity and integrity of DNS responses, thus mitigating DNS spoofing and cache poisoning attacks. The benefits of DNSSEC include: Data Integrity : It ensures that DNS data has not been altered in transit, providing data integrity. Authentication : It allows resolvers to authenticate that the DNS data they receive is from an authoritative source. Trustworthiness : It builds a chain of trust from the root zone down to individual domains, making it harder for attackers to spoof DNS data. Note : DNSSEC authenticates and assures data integrity but doesn't encrypt DNS exchanges. For encryption, protocols like DNS over HTTPS (DoH) and DNS over TLS (DoT) are employed, as described next. DNS-over-HTTPS (DoH) DNS over HTTPS (DoH) is a protocol that enhances the privacy and security of DNS queries by encrypting them within the HTTPS (Hypertext Transfer Protocol Secure) protocol. With DoH, the DNS resolver uses the HTTPS protocol to send and receive DNS queries and responses. DNS-over-TLS (DoT) DNS over TLS (DoT) is an alternative to DoH. Like DNS over HTTPS, it enhances the privacy and security of DNS queries by encrypting them using the Transport Layer Security (TLS) protocol. With DNS over TLS, the DNS resolver establishes an encrypted TLS connection with your device to transmit DNS queries and responses. Both of these protocols provide similar benefits in terms of protecting DNS traffic from eavesdropping and tampering. We are going to list some of the key benefits of DoH and DoT below: Privacy: Both DoH and DoT encrypt your DNS queries, preventing third parties, including ISPs, from monitoring and intercepting your browsing history. This helps protect your online privacy. Security : Encrypting DNS queries helps prevent DNS spoofing and man-in-the-middle attacks, where malicious actors could intercept DNS traffic and redirect it to malicious websites. Censorship Resistance : DoH and DoT can bypass some forms of DNS-based censorship or content filtering, as it makes it harder for authorities to inspect and block specific DNS requests. Improved Trust : By leveraging the security mechanisms of HTTPS and TLS, DoH and DoT add an additional layer of trust to DNS resolution, making it more resistant to attacks and tampering. Since both DoH and DoT provide similar benefits, the natural question is, when to use which one? The answer to this question depends on various factors, and neither is inherently better than the other. Here are the key differences between the two protocols: [ ](https://substackcdn.com/image/fetch/$s_!ob6N!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ffab41b83-3fb4-4567-83ac-fb1cf8ae085a_1646x1045.jpeg) Common Security Threats to DNS Now that we have explained popular security protocols in DNS, let\u2019s briefly describe some of the common security threats to DNS and ways to protect against them. DNS Cache Poisoning DNS cache poisoning occurs when malicious DNS data is introduced into the DNS resolver's cache, leading it to direct users to malicious websites. DNS cache poisoning is also known as \u2018DNS Spoofing\u2019. To protect against this threat, we can: Implement DNSSEC (DNS Security Extensions) to add cryptographic signatures to DNS records, ensuring data integrity. Use DNS servers that implement query-response validation to prevent caching of malicious data. Regularly update and patch DNS servers to fix vulnerabilities that could be exploited for cache poisoning. Distributed Denial of Service (DDoS) Attacks A DDoS attack is a malicious attempt to overwhelm and disrupt the normal functioning of DNS servers by flooding them with a massive volume of traffic, rendering them unavailable. To mitigate DDoS attacks: Distribute DNS servers across multiple locations and use load balancing to handle traffic spikes. Implement rate limiting and traffic filtering rules on your DNS servers. Man-in-the-Middle (MitM) Attacks In a MitM attack, an attacker intercepts DNS traffic to redirect users to malicious sites or eavesdrop on their communications. To protect against MitM attacks: Use DNSSEC to validate the authenticity of DNS responses. Implement DNS over HTTPS (DoH) or DNS over TLS (DoT) to encrypt DNS traffic. Monitor network traffic for unusual DNS resolution patterns. DNS Hijacking DNS hijacking occurs when attackers gain control of a domain's DNS settings and redirect traffic to malicious servers. Protect against DNS hijacking by: Enabling two-factor authentication (2FA) for domain registrar accounts. Monitoring DNS records for unauthorized changes. DNS security requires a multi-layered approach, including a combination of encryption, access controls, monitoring, and patch management. Regularly review and update your DNS security practices to adapt to evolving threats. DNS for IPv6 DNS for IPv6, often referred to as DNS6, serves a similar fundamental purpose as DNS for IPv4, but it is adapted to the IPv6 addressing scheme and offers some improvements and changes to accommodate the larger address space and other features of IPv6. Here\u2019s how DNS for IPv6 differs from DNS for IPv4: Address Format : IPv4 uses 32-bit addresses, while IPv6 uses 128-bit addresses. In DNS for IPv6, these longer addresses are represented using hexadecimal notation, separated by colons. For instance, an IPv6 address might look like 2001:0db8:85a3:1111:2222:3333:4444:5555. AAAA Records : In DNS for IPv6, the primary record for mapping domain names to IPv6 addresses is the AAAA (pronounced \"quad-A\") record. This is analogous to the A record in DNS for IPv4. When you query a DNS server for the AAAA record of a domain, it returns the corresponding IPv6 address. Reverse DNS : Just like in DNS for IPv4, reverse DNS lookup in DNS for IPv6 maps IPv6 addresses back to domain names. For example, if you have an IPv6 address and want to find the associated domain name, you can perform a reverse DNS lookup using a PTR record. IPv6-Only DNS Servers : While DNS servers can support both IPv4 and IPv6 (dual-stack), there are also DNS servers designed to work exclusively with IPv6 without any reliance on IPv4. This is especially important in IPv6-only network environments. DNSSEC for IPv6 : DNSSEC (Domain Name System Security Extensions) is a security feature that is fully compatible with both DNS for IPv4 and DNS for IPv6, providing security enhancements for domain name resolution in both IP versions. IPv6 Transport : DNS for IPv6 can use IPv6 transport exclusively for communication between DNS clients and servers, reducing the reliance on IPv4 for DNS resolution. Summary This wraps up our discussion of the DNS, which is a critical name resolution service for the internet. We talked about crucial functions of DNS, including mapping domain names to IP addresses, managing host aliases, mail server aliases, and reverse DNS lookups. The DNS hierarchy involves root servers, top-level domain (TLD) servers, authoritative servers, and recursive DNS servers. Then, we discussed the two DNS resolution methods, iterative and recursive, which play a vital role in DNS functioning. DNS caching optimizes resolution speed by storing results for a set time. DNS Resource Records (RRs) store data in DNS databases, including various record types like Type A, NS, CNAME, and MX records. Lastly, we presented some of the common threats to DNS and ways to avoid them. Keep exploring, keep learning.","title":"A Crash Course in DNS (Domain Name System)"},{"location":"A%20Crash%20Course%20in%20DNS%20%28Domain%20Name%20System%29/#dns-the-internets-address-book","text":"DNS is a distributed and hierarchical system that acts as the internet's address book. It translates domain names into IP addresses to facilitate efficient communication between devices across the globe. The primary purpose of DNS is to provide a convenient way for users to access websites and resources using easily memorable domain names, while computers and servers use IP addresses for communication behind the scenes. The DNS is implemented as an Application layer service. It is implemented by the servers that sit at the network edge rather than routers and switches inside the network. This reflects the internet design philosophy of keeping the network core simple and putting complexity at the network\u2019s edge.","title":"DNS: The Internet\u2019s Address Book"},{"location":"A%20Crash%20Course%20in%20DNS%20%28Domain%20Name%20System%29/#key-services-provided-by-dns","text":"DNS provides a number of different services to facilitate the functioning of the Internet. Here is a mind map of the services provided by DNS. We are going to describe some of the most vital services of DNS below:","title":"Key Services Provided by DNS"},{"location":"A%20Crash%20Course%20in%20DNS%20%28Domain%20Name%20System%29/#host-to-ip-address-mapping","text":"DNS maintains a database of domain names and their corresponding IP addresses. This mapping is essential for devices to locate each other on the internet. For instance, consider the domain name \"www.bytebytego.com.\" Host-to-IP address mapping involves determining the IP address associated with this domain, such as \"172.67.21.11\".","title":"Host-to-IP address mapping"},{"location":"A%20Crash%20Course%20in%20DNS%20%28Domain%20Name%20System%29/#host-aliasing","text":"DNS supports a feature commonly known as host aliasing, enabled through CNAME (Canonical Name) records. This allows a single IP address or primary domain name to be associated with multiple domain name aliases. For example, let's consider the primary domain \"bytebytego.com\". You might want your website to be accessible not just via \"bytebytego.com\", but also through various aliases like \"www.bytebytego.com\", \"web.bytebytego.com\", and \"blog.bytebytego.com\". By setting up appropriate CNAME records in DNS, all these aliases can point to the primary domain \"bytebytego.com\". As a result, users can access your website using any of these domain names, all leading to the same destination IP address.","title":"Host aliasing"},{"location":"A%20Crash%20Course%20in%20DNS%20%28Domain%20Name%20System%29/#email-routing","text":"DNS plays a crucial role in email routing through MX records. These records allow a domain to specify which mail servers are responsible for receiving email messages on its behalf. This mechanism enables flexibility in email configurations. For example, let's say the primary mail server designated to receive emails for the \"bytebytego.com\" domain is \"mail.bytebytego.com\". You might want to have specific email addresses, such as those ending in \"@sales.bytebytego.com\" or \"@support.bytebytego.com\", yet still direct all incoming mail for these addresses to the \"mail.bytebytego.com\" server. By configuring MX records appropriately, emails sent to any of these addresses will route to the designated primary mail server.","title":"Email Routing"},{"location":"A%20Crash%20Course%20in%20DNS%20%28Domain%20Name%20System%29/#ip-to-host-address-mapping","text":"While DNS is primarily used for translating domain names to IP addresses, it can also perform reverse lookups, translating IP addresses back to domain names. This is useful for security and logging purposes.","title":"IP-to-host address mapping"},{"location":"A%20Crash%20Course%20in%20DNS%20%28Domain%20Name%20System%29/#load-balancing","text":"DNS can distribute incoming network traffic across multiple servers by returning different IP addresses in response to the same domain name query. This helps balance the load and improve the performance and reliability of online services.","title":"Load balancing"},{"location":"A%20Crash%20Course%20in%20DNS%20%28Domain%20Name%20System%29/#dns-hierarchy","text":"DNS operates as a distributed hierarchical database. The following illustration shows a high-level view of the DNS hierarchy. [ ](https://substackcdn.com/image/fetch/$s_!P_Ol!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff0a1bb2c-a1bc-40ce-abde-6fb9d2a66ce8_1600x570.png)","title":"DNS Hierarchy"},{"location":"A%20Crash%20Course%20in%20DNS%20%28Domain%20Name%20System%29/#root-dns-servers","text":"At the top of the DNS hierarchy are the root servers. The root servers are contacted when a server is not actually able to resolve a name. You can think of it as a first point of contact to get the resolution started. Root servers act like the central nervous system of the internet, and as such, security is going to be very important. Much of the infrastructure associated with the root servers is the responsibility of ICANN (Internet Corporation for Assigned Names and Numbers). There are 13 logical root servers around the world, but each of these logical root servers is actually replicated, so corresponding to these 13 logical servers are actually close to a thousand physical servers around the world.","title":"Root DNS Servers"},{"location":"A%20Crash%20Course%20in%20DNS%20%28Domain%20Name%20System%29/#top-level-domain-tld-dns-servers","text":"Moving down a level from the root servers, we find the TLD (Top-Level Domain) servers and each of the servers in the TLD layer is responsible for resolving one of the addresses that have an ending like .com , .edu , .net , and .org . The Internet Corporation for Assigned Names and Numbers (ICANN) has authority over all TLDs used on the Internet, and it delegates the responsibility of these TLDs to various organizations. For individuals or entities looking to register a new domain under these TLDs, they typically approach Domain Name Registrars, which are accredited entities interfacing with the registries to handle the registration process.","title":"Top-Level Domain (TLD) DNS servers"},{"location":"A%20Crash%20Course%20in%20DNS%20%28Domain%20Name%20System%29/#authoritative-dns-servers","text":"Authoritative servers are the definitive source for domain name resolutions within their specific domain. They store the actual name-to-IP address mappings for a given domain. While various caching mechanisms exist across the internet to speed up domain name resolutions, it's the authoritative servers that provide the correct and final answer when queried. Domain owners or administrators configure their domain's records, but the actual infrastructure\u2014the DNS servers\u2014is often maintained and operated by DNS hosting providers or registrars like Cloudflare, Namecheap, GoDaddy, and others.","title":"Authoritative DNS servers"},{"location":"A%20Crash%20Course%20in%20DNS%20%28Domain%20Name%20System%29/#recursive-dns-servers-resolver","text":"Recursive servers handle DNS queries from client devices like computers and smartphones. When a device wants to resolve a domain name, it contacts these servers. Acting on behalf of the client, recursive servers traverse the DNS hierarchy, consulting various DNS servers to determine the IP address associated with a domain name. Once they obtain the answer, they return it to the client. For efficiency, recursive servers often cache responses to avoid repeatedly querying the same information. Check out the illustration below, it shows the placement of some of the main DNS servers inside the pipeline of a DNS query. [ ](https://substackcdn.com/image/fetch/$s_!2I4b!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F99472ff8-82a1-4365-bb03-c9a00b39e412_1419x336.png)","title":"Recursive DNS Servers (Resolver)"},{"location":"A%20Crash%20Course%20in%20DNS%20%28Domain%20Name%20System%29/#how-dns-resolution-works","text":"There are two main methods of query resolution in DNS: Iterative query resolution Recursive query resolution These methods define how DNS servers interact with each other to find the IP address associated with a given domain name. Here\u2019s a brief overview of each method. Iterative Query Resolution In iterative query resolution, the DNS server receiving the query provides referrals to the querying server, guiding it through the DNS hierarchy. The querying server actively participates in the process by sending subsequent queries based on the referrals received. Let's try to understand the workings of iterative query resolution with the help of an example shown in the illustration below. [ ](https://substackcdn.com/image/fetch/$s_!eaJb!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F96fbf5fc-bf5d-4047-b058-f48f6f3b3a30_1600x1432.png) Suppose the requesting host is making a request to resolve the name bytebytego.com . Here\u2019s how this is going to unfold: The host first sends a query message to the local DNS resolver. The query message contains the hostname to be translated bytebytego.com If the resolver doesn't have the IP address in its cache, it sends a query to a root DNS server. The root DNS server, recognizing the .com suffix, provides a referral to TLD servers responsible for .com The resolver then sends a new query to one of these TLD servers. The TLD server provides a referral to the authoritative DNS server responsible for bytebytego.com . The resolver sends another query to the authoritative DNS server. The authoritative DNS server responds with the IP address of bytebytego.com The DNS resolver caches this IP address and then returns it to the requesting host. Now, the requesting host makes an HTTP request to the IP address of the http://www.bytebytego.com web server. The web server returns the webpage for www.bytebytego.com","title":"How DNS Resolution Works"},{"location":"A%20Crash%20Course%20in%20DNS%20%28Domain%20Name%20System%29/#recursive-query-resolution","text":"In recursive query resolution, the DNS server receiving the query takes on the responsibility of finding the IP address on behalf of the client. It may itself use iterative queries to navigate through the DNS hierarchy until it reaches the authoritative DNS server for the requested domain. Let\u2019s use the previous example and try to resolve the IP address of bytebytego.com using the recursive query resolution as shown in the illustration below: [ ](https://substackcdn.com/image/fetch/$s_!ZguZ!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F23550856-e23b-4372-8422-20630dfea888_1600x1432.png) We have summarized the steps shown in the above illustration as follows: The client sends a query to the local DNS resolver. The resolver checks its cache for the IP address. If not found, it conducts the necessary queries\u2014possibly iterative ones\u2014interacting with root DNS servers, then TLD DNS servers, and finally authoritative DNS servers until it obtains the IP address. Once found, the resolver caches the IP address and returns it to the client. Subsequent queries for the same domain can be answered directly from the resolver's cache. Both iterative and recursive query resolution methods are vital to the functioning of the DNS. Recursive queries simplify the process for clients, with the resolver managing the hierarchical queries and caching. Iterative queries involve the querying server actively following referrals to find the IP address. Note : In practice, most client devices send queries to recursive DNS resolvers, which often use a mix of recursive and iterative queries behind the scenes to fetch and cache results, ensuring efficient operation of the global DNS system.","title":"Recursive Query Resolution"},{"location":"A%20Crash%20Course%20in%20DNS%20%28Domain%20Name%20System%29/#caching-in-dns","text":"DNS resolution involves several steps, and to expedite repeated resolutions of the same domain names, the system leverages caching. Caching recently resolved DNS query results can drastically reduce the number of repeated queries to authoritative DNS servers. By caching DNS records, the efficiency and speed of DNS resolution is significantly improved. It reduces the need for recursive servers to navigate the entire DNS hierarchy every time a domain is queried.","title":"Caching in DNS"},{"location":"A%20Crash%20Course%20in%20DNS%20%28Domain%20Name%20System%29/#where-does-dns-caching-occur","text":"DNS records are cached at various points in the resolution process. The duration for which a record is cached is determined by its time-to-live (TTL) value. At the local machine : Devices like computers and smartphones have local DNS caches. When you visit a website, your device's DNS resolver stores the resolved IP address along with the associated domain name in its cache. This way, if you visit the same website again or access resources on the same domain, the DNS resolution process is faster. At the recursive DNS server : Recursive DNS servers, often maintained by ISPs and other organizations, cache DNS records. This benefits multiple users within the same network accessing the same domain, as the cached record can be provided without querying the entire DNS hierarchy again. At the authoritative DNS server : While it might seem counterintuitive, even authoritative DNS servers (which hold the official domain records) use caching. This helps in efficiently handling high query volumes and reduces redundant processing. Note : Cached DNS records can become outdated if the original record changes. However, outdated cache entries are not a major concern in the DNS system. They will be automatically removed when their TTL expires.","title":"Where does DNS caching occur?"},{"location":"A%20Crash%20Course%20in%20DNS%20%28Domain%20Name%20System%29/#dns-propagation","text":"After registering or updating a domain, there might be a delay before the domain is accessible universally. This delay is called DNS Propagation. Let\u2019s try to understand this concept with the help of an example. Imagine you've registered a domain, mywebsite.com, with GoDaddy, a popular domain registrar. If you try to access this domain immediately after registration, you might encounter issues. [ ](https://substackcdn.com/image/fetch/$s_!FTpt!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fcdca2ea4-1490-443c-9883-e431c1394bc3_1600x555.png) Despite updating the record at the authoritative server, many recursive DNS servers and local caches around the world might still have the old (or non-existent) record cached. Until these cached records expire (as per their TTL) and are replaced with the updated record, users might face access issues. This period of inconsistency, where different parts of the world might see different records, is DNS Propagation. Typically, most DNS propagations complete within 24-48 hours, but the commonly cited upper limit is 72 hours. However, it's essential to set reasonable TTL values to ensure rapid propagation when changes are made.","title":"DNS propagation"},{"location":"A%20Crash%20Course%20in%20DNS%20%28Domain%20Name%20System%29/#dns-resource-records-rrs","text":"Now, let\u2019s talk about how data is being stored in DNS databases. Data in DNS is stored in the form of Resource Records (RRs). When a device queries a DNS server about a domain name, the server provides the relevant RRs, helping the device access the desired resource on the internet. Here is the structure of a DNS resource record: [ ](https://substackcdn.com/image/fetch/$s_!-tUg!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff3c5ba97-c19c-4a0c-9b0f-128f9f5413f9_1188x489.png) Most of the fields in the RR are self-explanatory. However, we would like to discuss the Type field in more detail. There are different types of DNS resource records, but here we discuss four common RR types in DNS: Type A record (Address record): Maps a domain name to an IPv4 address. It's used to translate human-readable domain names into numerical IP addresses as shown below. Type NS record (Name Server record): Specifies the authoritative name servers for a domain. These name servers hold the official DNS records for the domain. Type CNAME record (Canonical Name record): Creates an alias for a domain name, pointing it to another domain's canonical (real) name. Type MX record (Mail Exchange record): Specifies the mail servers responsible for receiving email messages for a domain. The below illustration shows these four types when used in a DNS query and their corresponding DNS responses. [ ](https://substackcdn.com/image/fetch/$s_!MUtQ!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F887873eb-a776-44b4-84b4-2485ea590992_1600x1406.png)","title":"DNS Resource Records (RRs)"},{"location":"A%20Crash%20Course%20in%20DNS%20%28Domain%20Name%20System%29/#dynamic-dns","text":"An essential extension of DNS is the Dynamic DNS (DDNS). This service allows users to automatically update the mapping between domain names and IP addresses whenever the IP address changes. The primary use-case for Dynamic DNS is to support hosts that have dynamic IP addresses, like those assigned by many residential ISPs. DDNS is invaluable for individuals and small businesses wanting to host services, websites, or devices on networks with dynamic IP addresses. It ensures consistent remote access by providing a stable domain name that always points to the current IP address, even if that address changes frequently.","title":"Dynamic DNS"},{"location":"A%20Crash%20Course%20in%20DNS%20%28Domain%20Name%20System%29/#dns-and-anycast","text":"Anycast is a network addressing and routing methodology where multiple servers share the same IP address. When a client sends a request to an Anycast IP address, the network determines the closest server (in terms of routing efficiency) to serve that request. Using Anycast in DNS provides benefits such as faster response times due to reduced latency, better load distribution among servers, and enhanced redundancy. If one server fails, the network automatically reroutes requests to another available server. Many TLD name servers and major DNS service providers leverage Anycast to improve the performance, reliability, and resilience of their services.","title":"DNS and Anycast"},{"location":"A%20Crash%20Course%20in%20DNS%20%28Domain%20Name%20System%29/#dns-security","text":"Now that you understand what the DNS does, you can see how absolutely critical it is to the functioning of the internet. If the DNS stopped working, it\u2019d be impossible to contact any host unless you knew its IP address, which means practically never. So it's critical the DNS be protected. Below, we discuss some of the most popular security protocols to protect DNS:","title":"DNS Security"},{"location":"A%20Crash%20Course%20in%20DNS%20%28Domain%20Name%20System%29/#dnssec","text":"Domain Name System Security Extensions (DNSSEC) is a set of extensions to DNS that adds an additional layer of security by digitally signing DNS data. It helps in ensuring the authenticity and integrity of DNS responses, thus mitigating DNS spoofing and cache poisoning attacks. The benefits of DNSSEC include: Data Integrity : It ensures that DNS data has not been altered in transit, providing data integrity. Authentication : It allows resolvers to authenticate that the DNS data they receive is from an authoritative source. Trustworthiness : It builds a chain of trust from the root zone down to individual domains, making it harder for attackers to spoof DNS data. Note : DNSSEC authenticates and assures data integrity but doesn't encrypt DNS exchanges. For encryption, protocols like DNS over HTTPS (DoH) and DNS over TLS (DoT) are employed, as described next.","title":"DNSSEC"},{"location":"A%20Crash%20Course%20in%20DNS%20%28Domain%20Name%20System%29/#dns-over-https-doh","text":"DNS over HTTPS (DoH) is a protocol that enhances the privacy and security of DNS queries by encrypting them within the HTTPS (Hypertext Transfer Protocol Secure) protocol. With DoH, the DNS resolver uses the HTTPS protocol to send and receive DNS queries and responses.","title":"DNS-over-HTTPS (DoH)"},{"location":"A%20Crash%20Course%20in%20DNS%20%28Domain%20Name%20System%29/#dns-over-tls-dot","text":"DNS over TLS (DoT) is an alternative to DoH. Like DNS over HTTPS, it enhances the privacy and security of DNS queries by encrypting them using the Transport Layer Security (TLS) protocol. With DNS over TLS, the DNS resolver establishes an encrypted TLS connection with your device to transmit DNS queries and responses. Both of these protocols provide similar benefits in terms of protecting DNS traffic from eavesdropping and tampering. We are going to list some of the key benefits of DoH and DoT below: Privacy: Both DoH and DoT encrypt your DNS queries, preventing third parties, including ISPs, from monitoring and intercepting your browsing history. This helps protect your online privacy. Security : Encrypting DNS queries helps prevent DNS spoofing and man-in-the-middle attacks, where malicious actors could intercept DNS traffic and redirect it to malicious websites. Censorship Resistance : DoH and DoT can bypass some forms of DNS-based censorship or content filtering, as it makes it harder for authorities to inspect and block specific DNS requests. Improved Trust : By leveraging the security mechanisms of HTTPS and TLS, DoH and DoT add an additional layer of trust to DNS resolution, making it more resistant to attacks and tampering. Since both DoH and DoT provide similar benefits, the natural question is, when to use which one? The answer to this question depends on various factors, and neither is inherently better than the other. Here are the key differences between the two protocols: [ ](https://substackcdn.com/image/fetch/$s_!ob6N!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ffab41b83-3fb4-4567-83ac-fb1cf8ae085a_1646x1045.jpeg)","title":"DNS-over-TLS (DoT)"},{"location":"A%20Crash%20Course%20in%20DNS%20%28Domain%20Name%20System%29/#common-security-threats-to-dns","text":"Now that we have explained popular security protocols in DNS, let\u2019s briefly describe some of the common security threats to DNS and ways to protect against them.","title":"Common Security Threats to DNS"},{"location":"A%20Crash%20Course%20in%20DNS%20%28Domain%20Name%20System%29/#dns-cache-poisoning","text":"DNS cache poisoning occurs when malicious DNS data is introduced into the DNS resolver's cache, leading it to direct users to malicious websites. DNS cache poisoning is also known as \u2018DNS Spoofing\u2019. To protect against this threat, we can: Implement DNSSEC (DNS Security Extensions) to add cryptographic signatures to DNS records, ensuring data integrity. Use DNS servers that implement query-response validation to prevent caching of malicious data. Regularly update and patch DNS servers to fix vulnerabilities that could be exploited for cache poisoning.","title":"DNS Cache Poisoning"},{"location":"A%20Crash%20Course%20in%20DNS%20%28Domain%20Name%20System%29/#distributed-denial-of-service-ddos-attacks","text":"A DDoS attack is a malicious attempt to overwhelm and disrupt the normal functioning of DNS servers by flooding them with a massive volume of traffic, rendering them unavailable. To mitigate DDoS attacks: Distribute DNS servers across multiple locations and use load balancing to handle traffic spikes. Implement rate limiting and traffic filtering rules on your DNS servers.","title":"Distributed Denial of Service (DDoS) Attacks"},{"location":"A%20Crash%20Course%20in%20DNS%20%28Domain%20Name%20System%29/#man-in-the-middle-mitm-attacks","text":"In a MitM attack, an attacker intercepts DNS traffic to redirect users to malicious sites or eavesdrop on their communications. To protect against MitM attacks: Use DNSSEC to validate the authenticity of DNS responses. Implement DNS over HTTPS (DoH) or DNS over TLS (DoT) to encrypt DNS traffic. Monitor network traffic for unusual DNS resolution patterns.","title":"Man-in-the-Middle (MitM) Attacks"},{"location":"A%20Crash%20Course%20in%20DNS%20%28Domain%20Name%20System%29/#dns-hijacking","text":"DNS hijacking occurs when attackers gain control of a domain's DNS settings and redirect traffic to malicious servers. Protect against DNS hijacking by: Enabling two-factor authentication (2FA) for domain registrar accounts. Monitoring DNS records for unauthorized changes. DNS security requires a multi-layered approach, including a combination of encryption, access controls, monitoring, and patch management. Regularly review and update your DNS security practices to adapt to evolving threats.","title":"DNS Hijacking"},{"location":"A%20Crash%20Course%20in%20DNS%20%28Domain%20Name%20System%29/#dns-for-ipv6","text":"DNS for IPv6, often referred to as DNS6, serves a similar fundamental purpose as DNS for IPv4, but it is adapted to the IPv6 addressing scheme and offers some improvements and changes to accommodate the larger address space and other features of IPv6. Here\u2019s how DNS for IPv6 differs from DNS for IPv4: Address Format : IPv4 uses 32-bit addresses, while IPv6 uses 128-bit addresses. In DNS for IPv6, these longer addresses are represented using hexadecimal notation, separated by colons. For instance, an IPv6 address might look like 2001:0db8:85a3:1111:2222:3333:4444:5555. AAAA Records : In DNS for IPv6, the primary record for mapping domain names to IPv6 addresses is the AAAA (pronounced \"quad-A\") record. This is analogous to the A record in DNS for IPv4. When you query a DNS server for the AAAA record of a domain, it returns the corresponding IPv6 address. Reverse DNS : Just like in DNS for IPv4, reverse DNS lookup in DNS for IPv6 maps IPv6 addresses back to domain names. For example, if you have an IPv6 address and want to find the associated domain name, you can perform a reverse DNS lookup using a PTR record. IPv6-Only DNS Servers : While DNS servers can support both IPv4 and IPv6 (dual-stack), there are also DNS servers designed to work exclusively with IPv6 without any reliance on IPv4. This is especially important in IPv6-only network environments. DNSSEC for IPv6 : DNSSEC (Domain Name System Security Extensions) is a security feature that is fully compatible with both DNS for IPv4 and DNS for IPv6, providing security enhancements for domain name resolution in both IP versions. IPv6 Transport : DNS for IPv6 can use IPv6 transport exclusively for communication between DNS clients and servers, reducing the reliance on IPv4 for DNS resolution.","title":"DNS for IPv6"},{"location":"A%20Crash%20Course%20in%20DNS%20%28Domain%20Name%20System%29/#summary","text":"This wraps up our discussion of the DNS, which is a critical name resolution service for the internet. We talked about crucial functions of DNS, including mapping domain names to IP addresses, managing host aliases, mail server aliases, and reverse DNS lookups. The DNS hierarchy involves root servers, top-level domain (TLD) servers, authoritative servers, and recursive DNS servers. Then, we discussed the two DNS resolution methods, iterative and recursive, which play a vital role in DNS functioning. DNS caching optimizes resolution speed by storing results for a set time. DNS Resource Records (RRs) store data in DNS databases, including various record types like Type A, NS, CNAME, and MX records. Lastly, we presented some of the common threats to DNS and ways to avoid them. Keep exploring, keep learning.","title":"Summary"},{"location":"Training-Portal/Integrating-A-New-App/","text":"Integrating a New Application (Package Pro) Tutorial This tutorial explains step-by-step how we integrated \"Package Pro\" into the Training Portal. The goal is for you to understand the why and how behind each change, from the frontend static files all the way to the Symfony backend database and EasyAdmin dashboard. Whether you replicate this for another app or just want to understand the codebase better, these chapters will guide you through the process we used. Chapter 1: The Frontend (Static Files) What we did: We copied the package-pro folder into the public/ directory of the Symfony project. Why: The Training Portal is designed with a decoupled architecture. The \"games\" (DNS Detective, Package Pro) are standalone static applications written in raw HTML, CSS, and JS. Symfony does not use Twig to render their inner logic. By placing the folder in public/package-pro , the web server (or the Symfony local server) serves those static files directly at http://localhost:8000/package-pro/ . This keeps the frontend completely isolated. Symfony's main job is simply tracking progress and serving as an admin interface to manage the data. Chapter 2: The Database \"App\" Entity To make Package Pro show up in the EasyAdmin dashboard (the portal backend), we needed to tell the database that this app exists. The blueprint for database tables in Symfony is an Entity . Adding Missing Fields What we did: We modified src/Entity/App.php . We noticed that when we tried to seed the database, properties like description , icon , colorTheme , and isActive were missing, causing a fatal PHP error. Why: In Doctrine (Symfony's database ORM tool), PHP class properties mapped with #[ORM\\Column] attributes define the actual table columns. We added: #[ORM\\Column(type: 'text', nullable: true)] public ?string $description = null; #[ORM\\Column(length: 50, nullable: true)] public ?string $icon = null; #[ORM\\Column(length: 50, nullable: true)] public ?string $colorTheme = null; #[ORM\\Column(type: 'boolean', options: ['default' => true])] public bool $isActive = true; Note on isActive : We initially forgot the options: ['default' => true] . Because the database already had data (the DNS Detective row), adding a NOT NULL boolean column ( bool $isActive without a ? ) made SQLite/Database complain: \"Cannot add a NOT NULL column without a default value.\" We fixed that by providing the default value directly in the ORM attribute. Chapter 3: Running Migrations What we did: We ran php bin/console make:migration and then php bin/console doctrine:migrations:migrate . Why: Editing an Entity file in PHP does not automatically change the database. 1. make:migration compares your PHP files to your current database schema and generates a raw SQL file ( VersionXXXX.php in the migrations/ folder) containing the ALTER TABLE commands needed to bridge the gap. 2. doctrine:migrations:migrate safely executes that SQL file. This ensures the database stays perfectly synced with your code. Chapter 4: Seeding The Data (The Tricky Part!) To create the initial data, we wrote a PHP script: bin/seed_package_pro.php . Step 4.1: The App Table What we did: We created a new instance of the App entity and assigned it the values for Package Pro. $app = new App(); $app->name = 'Package Pro'; $app->slug = 'package-pro'; // ... set description, icon, etc. $em->persist($app); Why: $em is the EntityManager . Calling persist() tells Doctrine \"start tracking this object\". Calling flush() actually writes it to the database with an INSERT statement. Step 4.2: Realizing We Forgot the Cases! Initially, we stopped there. Package Pro showed up on the EasyAdmin dashboard... but it was completely empty inside. It had no \"Course Cases\" or \"Quiz Questions\". We hadn't seeded them! Step 4.3: Extracting Data from Javascript What we did: The app.js file for Package Pro contained a massive CASES Javascript object storing all the scenario text, questions, and answers. Typing them out by hand in PHP would be terrible. Instead, we: 1. Wrote a quick Node.js script to extract the CASES block from app.js and save it as a JSON file ( /tmp/package_pro_cases.json ). 2. Updated our PHP seed script to file_get_contents() and json_decode() that JSON back into a PHP array. 3. Created CourseCase , Step , and Question entities in a loop for every case we found. foreach ($casesData as $data) { // 1. Create the Course Case $case = new CourseCase(); $case->app = $app; // Link it back to the main App! $case->title = $data['title']; $em->persist($case); // 2. Loop through steps in the case foreach ($data['steps'] as $stepData) { $step = new Step(); $step->courseCase = $case; // Link it back to the Case // ... set step properties $em->persist($step); // 3. Loop through quiz questions in the step foreach ($stepData['questions'] as $qData) { $q = new Question(); $q->step = $step; // Link it back to the Step // ... set question properties $em->persist($q); } } } $em->flush(); // Commit all 150+ rows to the database at once! Why: A relational database requires these connections. An App One-to-Many CourseCases . A CourseCase One-to-Many Steps . And a Step One-to-Many Questions . Setting these properties effectively creates the Foreign Key relationships. Chapter 5: Fixing the EasyAdmin Dashboard Error What we did: Early on, when you tried to load /admin , EasyAdmin threw a fatal runtime error: \"Call to undefined method MenuItem::linkToCrud()\" . We fixed this in DashboardController.php . Why: The code you had earlier was for EasyAdmin version 3.x. However, the project's composer.json specified \"easycorp/easyadmin-bundle\": \"*\" , which installed the newest Version 4.x. In EasyAdmin 4, MenuItem::linkToCrud() was deleted. Replacing it was easy: - yield MenuItem::linkToCrud('Apps', 'fa fa-graduation-cap', App::class); + yield MenuItem::linkTo(AppCrudController::class, 'Apps', 'fa fa-graduation-cap'); You now pass the fully qualified class name of the Controller rather than the Entity , using the newer linkTo() method. Summary You now have a complete, working knowledge of the data pipeline for your portal! 1. Frontend: Static HTML/JS in public/{app-name} 2. Backend Structure: src/Entity/{Name}.php models the tables. 3. Database Changes: make:migration -> migrate 4. Data Population: Custom bin/seed_{app}.php scripts to parse text/JSON and persist() objects. 5. Dashboard UI: EasyAdmin ...CrudController.php files automatically render grids based on the database data!","title":"Integrating a New Application (Package Pro) Tutorial"},{"location":"Training-Portal/Integrating-A-New-App/#integrating-a-new-application-package-pro-tutorial","text":"This tutorial explains step-by-step how we integrated \"Package Pro\" into the Training Portal. The goal is for you to understand the why and how behind each change, from the frontend static files all the way to the Symfony backend database and EasyAdmin dashboard. Whether you replicate this for another app or just want to understand the codebase better, these chapters will guide you through the process we used.","title":"Integrating a New Application (Package Pro) Tutorial"},{"location":"Training-Portal/Integrating-A-New-App/#chapter-1-the-frontend-static-files","text":"What we did: We copied the package-pro folder into the public/ directory of the Symfony project. Why: The Training Portal is designed with a decoupled architecture. The \"games\" (DNS Detective, Package Pro) are standalone static applications written in raw HTML, CSS, and JS. Symfony does not use Twig to render their inner logic. By placing the folder in public/package-pro , the web server (or the Symfony local server) serves those static files directly at http://localhost:8000/package-pro/ . This keeps the frontend completely isolated. Symfony's main job is simply tracking progress and serving as an admin interface to manage the data.","title":"Chapter 1: The Frontend (Static Files)"},{"location":"Training-Portal/Integrating-A-New-App/#chapter-2-the-database-app-entity","text":"To make Package Pro show up in the EasyAdmin dashboard (the portal backend), we needed to tell the database that this app exists. The blueprint for database tables in Symfony is an Entity .","title":"Chapter 2: The Database \"App\" Entity"},{"location":"Training-Portal/Integrating-A-New-App/#adding-missing-fields","text":"What we did: We modified src/Entity/App.php . We noticed that when we tried to seed the database, properties like description , icon , colorTheme , and isActive were missing, causing a fatal PHP error. Why: In Doctrine (Symfony's database ORM tool), PHP class properties mapped with #[ORM\\Column] attributes define the actual table columns. We added: #[ORM\\Column(type: 'text', nullable: true)] public ?string $description = null; #[ORM\\Column(length: 50, nullable: true)] public ?string $icon = null; #[ORM\\Column(length: 50, nullable: true)] public ?string $colorTheme = null; #[ORM\\Column(type: 'boolean', options: ['default' => true])] public bool $isActive = true; Note on isActive : We initially forgot the options: ['default' => true] . Because the database already had data (the DNS Detective row), adding a NOT NULL boolean column ( bool $isActive without a ? ) made SQLite/Database complain: \"Cannot add a NOT NULL column without a default value.\" We fixed that by providing the default value directly in the ORM attribute.","title":"Adding Missing Fields"},{"location":"Training-Portal/Integrating-A-New-App/#chapter-3-running-migrations","text":"What we did: We ran php bin/console make:migration and then php bin/console doctrine:migrations:migrate . Why: Editing an Entity file in PHP does not automatically change the database. 1. make:migration compares your PHP files to your current database schema and generates a raw SQL file ( VersionXXXX.php in the migrations/ folder) containing the ALTER TABLE commands needed to bridge the gap. 2. doctrine:migrations:migrate safely executes that SQL file. This ensures the database stays perfectly synced with your code.","title":"Chapter 3: Running Migrations"},{"location":"Training-Portal/Integrating-A-New-App/#chapter-4-seeding-the-data-the-tricky-part","text":"To create the initial data, we wrote a PHP script: bin/seed_package_pro.php .","title":"Chapter 4: Seeding The Data (The Tricky Part!)"},{"location":"Training-Portal/Integrating-A-New-App/#step-41-the-app-table","text":"What we did: We created a new instance of the App entity and assigned it the values for Package Pro. $app = new App(); $app->name = 'Package Pro'; $app->slug = 'package-pro'; // ... set description, icon, etc. $em->persist($app); Why: $em is the EntityManager . Calling persist() tells Doctrine \"start tracking this object\". Calling flush() actually writes it to the database with an INSERT statement.","title":"Step 4.1: The App Table"},{"location":"Training-Portal/Integrating-A-New-App/#step-42-realizing-we-forgot-the-cases","text":"Initially, we stopped there. Package Pro showed up on the EasyAdmin dashboard... but it was completely empty inside. It had no \"Course Cases\" or \"Quiz Questions\". We hadn't seeded them!","title":"Step 4.2: Realizing We Forgot the Cases!"},{"location":"Training-Portal/Integrating-A-New-App/#step-43-extracting-data-from-javascript","text":"What we did: The app.js file for Package Pro contained a massive CASES Javascript object storing all the scenario text, questions, and answers. Typing them out by hand in PHP would be terrible. Instead, we: 1. Wrote a quick Node.js script to extract the CASES block from app.js and save it as a JSON file ( /tmp/package_pro_cases.json ). 2. Updated our PHP seed script to file_get_contents() and json_decode() that JSON back into a PHP array. 3. Created CourseCase , Step , and Question entities in a loop for every case we found. foreach ($casesData as $data) { // 1. Create the Course Case $case = new CourseCase(); $case->app = $app; // Link it back to the main App! $case->title = $data['title']; $em->persist($case); // 2. Loop through steps in the case foreach ($data['steps'] as $stepData) { $step = new Step(); $step->courseCase = $case; // Link it back to the Case // ... set step properties $em->persist($step); // 3. Loop through quiz questions in the step foreach ($stepData['questions'] as $qData) { $q = new Question(); $q->step = $step; // Link it back to the Step // ... set question properties $em->persist($q); } } } $em->flush(); // Commit all 150+ rows to the database at once! Why: A relational database requires these connections. An App One-to-Many CourseCases . A CourseCase One-to-Many Steps . And a Step One-to-Many Questions . Setting these properties effectively creates the Foreign Key relationships.","title":"Step 4.3: Extracting Data from Javascript"},{"location":"Training-Portal/Integrating-A-New-App/#chapter-5-fixing-the-easyadmin-dashboard-error","text":"What we did: Early on, when you tried to load /admin , EasyAdmin threw a fatal runtime error: \"Call to undefined method MenuItem::linkToCrud()\" . We fixed this in DashboardController.php . Why: The code you had earlier was for EasyAdmin version 3.x. However, the project's composer.json specified \"easycorp/easyadmin-bundle\": \"*\" , which installed the newest Version 4.x. In EasyAdmin 4, MenuItem::linkToCrud() was deleted. Replacing it was easy: - yield MenuItem::linkToCrud('Apps', 'fa fa-graduation-cap', App::class); + yield MenuItem::linkTo(AppCrudController::class, 'Apps', 'fa fa-graduation-cap'); You now pass the fully qualified class name of the Controller rather than the Entity , using the newer linkTo() method.","title":"Chapter 5: Fixing the EasyAdmin Dashboard Error"},{"location":"Training-Portal/Integrating-A-New-App/#summary","text":"You now have a complete, working knowledge of the data pipeline for your portal! 1. Frontend: Static HTML/JS in public/{app-name} 2. Backend Structure: src/Entity/{Name}.php models the tables. 3. Database Changes: make:migration -> migrate 4. Data Population: Custom bin/seed_{app}.php scripts to parse text/JSON and persist() objects. 5. Dashboard UI: EasyAdmin ...CrudController.php files automatically render grids based on the database data!","title":"Summary"},{"location":"Training-Portal/Technical-Setup/","text":"Training Portal Technical Setup & Configuration Overview The Training Portal is a Symfony 7/8 application serving as a unified platform to host various training applications like DNS Detective and Package Pro . It provides an administrative backend built with EasyAdmin for managing courses, interactive cases, users, and progress tracking. Architecture Backend Framework: Symfony (latest Stable 7.x/8.x) Language Requirements: PHP 8.4+ Database: PostgreSQL (dev handled via Docker compose.yaml ) ORM System: Doctrine ORM Admin Interface: EasyCorp/EasyAdminBundle 4.x Frontend Architecture: Static HTML/CSS/JS applications mounted within the public/ directory. Core Applications Hosted DNS Detective Path: public/dns-detective/ Type: Single Page App (JS/HTML/CSS) Seeding: bin/seed_dns_detective.php Package Pro Path: public/package-pro/ Type: Single Page App (JS/HTML/CSS) Seeding: bin/seed_package_pro.php Both applications are registered in the main relational database as App entities and can be modified via the EasyAdmin interface. Local Development Setup To onboard developers to the project locally, run the following steps: 1. Start the Database Container A standard PostgreSQL Docker image is provided. docker compose up -d 2. Install Dependencies composer install 3. Environment Variables Ensure your .env or .env.local contains the correct DATABASE_URL . The default Docker setup expects: DATABASE_URL=\"postgresql://app:!ChangeMe!@127.0.0.1:5432/app?serverVersion=16&charset=utf8\" 4. Apply Database Migrations Create the necessary tables (Apps, CourseCases, Steps, Questions, Users, Progress): php bin/console doctrine:migrations:migrate --no-interaction 5. Seed the Database Populate the initial syllabus using the custom seed scripts: php bin/seed_dns_detective.php php bin/seed_package_pro.php 6. Start the Server symfony server:start -d # Admin UI accessible at: http://localhost:8000/admin Database Schema Highlights The relational schema heavily leverages Doctrine attributes. - App : Top-level entity (name, slug, description, icon, theme, isActive). - CourseCase : Dependent on App (title, xpReward, sortOrder). - Step & Question : Content building blocks associated directly to a CourseCase . - User , UserProgress , CompletedStep : Tracking progress across multiple apps and cases. Data Iteration Note: If new application entities require new properties, follow standard Doctrine migration flows: update the Entity PHP class properties (with e.g. #[ORM\\Column] ), then run make:migration , followed by doctrine:migrations:migrate . Key Technical Decisions Migration from EasyAdmin 3.x to 4.x Standards: The DashboardController.php menu items leverage MenuItem::linkTo(Controller::class) instead of the deprecated MenuItem::linkToCrud() . Decoupled Frontend: The frontend \"games\" (DNS Detective & Package Pro) do not use Twig routing. They are statically served standalone assets within /public . The Symfony backend strictly acts as their administrative layer.","title":"Training Portal Technical Setup &amp; Configuration"},{"location":"Training-Portal/Technical-Setup/#training-portal-technical-setup-configuration","text":"","title":"Training Portal Technical Setup &amp; Configuration"},{"location":"Training-Portal/Technical-Setup/#overview","text":"The Training Portal is a Symfony 7/8 application serving as a unified platform to host various training applications like DNS Detective and Package Pro . It provides an administrative backend built with EasyAdmin for managing courses, interactive cases, users, and progress tracking.","title":"Overview"},{"location":"Training-Portal/Technical-Setup/#architecture","text":"Backend Framework: Symfony (latest Stable 7.x/8.x) Language Requirements: PHP 8.4+ Database: PostgreSQL (dev handled via Docker compose.yaml ) ORM System: Doctrine ORM Admin Interface: EasyCorp/EasyAdminBundle 4.x Frontend Architecture: Static HTML/CSS/JS applications mounted within the public/ directory.","title":"Architecture"},{"location":"Training-Portal/Technical-Setup/#core-applications-hosted","text":"DNS Detective Path: public/dns-detective/ Type: Single Page App (JS/HTML/CSS) Seeding: bin/seed_dns_detective.php Package Pro Path: public/package-pro/ Type: Single Page App (JS/HTML/CSS) Seeding: bin/seed_package_pro.php Both applications are registered in the main relational database as App entities and can be modified via the EasyAdmin interface.","title":"Core Applications Hosted"},{"location":"Training-Portal/Technical-Setup/#local-development-setup","text":"To onboard developers to the project locally, run the following steps:","title":"Local Development Setup"},{"location":"Training-Portal/Technical-Setup/#1-start-the-database-container","text":"A standard PostgreSQL Docker image is provided. docker compose up -d","title":"1. Start the Database Container"},{"location":"Training-Portal/Technical-Setup/#2-install-dependencies","text":"composer install","title":"2. Install Dependencies"},{"location":"Training-Portal/Technical-Setup/#3-environment-variables","text":"Ensure your .env or .env.local contains the correct DATABASE_URL . The default Docker setup expects: DATABASE_URL=\"postgresql://app:!ChangeMe!@127.0.0.1:5432/app?serverVersion=16&charset=utf8\"","title":"3. Environment Variables"},{"location":"Training-Portal/Technical-Setup/#4-apply-database-migrations","text":"Create the necessary tables (Apps, CourseCases, Steps, Questions, Users, Progress): php bin/console doctrine:migrations:migrate --no-interaction","title":"4. Apply Database Migrations"},{"location":"Training-Portal/Technical-Setup/#5-seed-the-database","text":"Populate the initial syllabus using the custom seed scripts: php bin/seed_dns_detective.php php bin/seed_package_pro.php","title":"5. Seed the Database"},{"location":"Training-Portal/Technical-Setup/#6-start-the-server","text":"symfony server:start -d # Admin UI accessible at: http://localhost:8000/admin","title":"6. Start the Server"},{"location":"Training-Portal/Technical-Setup/#database-schema-highlights","text":"The relational schema heavily leverages Doctrine attributes. - App : Top-level entity (name, slug, description, icon, theme, isActive). - CourseCase : Dependent on App (title, xpReward, sortOrder). - Step & Question : Content building blocks associated directly to a CourseCase . - User , UserProgress , CompletedStep : Tracking progress across multiple apps and cases. Data Iteration Note: If new application entities require new properties, follow standard Doctrine migration flows: update the Entity PHP class properties (with e.g. #[ORM\\Column] ), then run make:migration , followed by doctrine:migrations:migrate .","title":"Database Schema Highlights"},{"location":"Training-Portal/Technical-Setup/#key-technical-decisions","text":"Migration from EasyAdmin 3.x to 4.x Standards: The DashboardController.php menu items leverage MenuItem::linkTo(Controller::class) instead of the deprecated MenuItem::linkToCrud() . Decoupled Frontend: The frontend \"games\" (DNS Detective & Package Pro) do not use Twig routing. They are statically served standalone assets within /public . The Symfony backend strictly acts as their administrative layer.","title":"Key Technical Decisions"},{"location":"Training-Portal/implementation_plan_authentication%20and%20leaderboard/","text":"Implementation Plan: User Tracking & Leaderboard Goal Description The objective is to allow trainees to log into the Training Portal, track their progress in the connected apps (DNS Detective & Package Pro), and display a global leaderboard for healthy competition. Currently, progress in DNS Detective and Package Pro is saved locally in the browser's localStorage (e.g., package_pro_progress ). We need to transition this to a persistent backend workflow using the Symfony database and an explicit user authentication system. Proposed Changes 1. User Authentication System We will implement a standard Symfony authentication flow. - Ensure the User entity implements UserInterface and PasswordAuthenticatedUserInterface . - Configure config/packages/security.yaml with a JSON login route (for the apps to hit) and an interactive web login route (for a future frontend portal). - Add controllers for Registration and Login. 2. API Endpoints for Progress Tracking Since API Platform is already installed and #[ApiResource] is present on App and UserProgress , we will leverage it instead of writing custom controllers from scratch. - [MODIFY] src/Entity/UserProgress.php and src/Entity/CompletedStep.php : Ensure they are mapped correctly so the frontend can POST and GET progress via the standard /api/user_progresses routes. - [MODIFY] Configure API Platform to automatically link the currently logged-in user to the progress records they create (using a custom DataPersister or StateProcessor). - [MODIFY] public/package-pro/app.js and public/dns-detective/app.js : Remove localStorage reliance. Update the saveProgress() and loadProgress() functions to make fetch() calls to the API Platform endpoints ( /api/user_progresses ). 3. Leaderboard Implementation We will create a query to aggregate XP across all apps and display it. - [NEW] src/Controller/Api/LeaderboardController.php : - GET /api/leaderboard : Returns a JSON array of the top 10/20 users ranked by total XP across all connected App entities. - [MODIFY] Add a \"Leaderboard\" modal or section to the frontend applications (or a central portal homepage) that fetches and displays this data. Verification Plan Automated/Manual Verification Create a dummy test user via the Symfony console or API. Log into the DNS Detective frontend using those credentials. Complete Case #1. Verify via the API and EasyAdmin Dashboard that a UserProgress row was created and updated correctly in the database. Refresh the page to verify that loadProgress() successfully fetches the state from the backend rather than local storage. Hit the /api/leaderboard endpoint to confirm the user's XP is correctly aggregated and ranked.","title":"Implementation Plan: User Tracking &amp; Leaderboard"},{"location":"Training-Portal/implementation_plan_authentication%20and%20leaderboard/#implementation-plan-user-tracking-leaderboard","text":"","title":"Implementation Plan: User Tracking &amp; Leaderboard"},{"location":"Training-Portal/implementation_plan_authentication%20and%20leaderboard/#goal-description","text":"The objective is to allow trainees to log into the Training Portal, track their progress in the connected apps (DNS Detective & Package Pro), and display a global leaderboard for healthy competition. Currently, progress in DNS Detective and Package Pro is saved locally in the browser's localStorage (e.g., package_pro_progress ). We need to transition this to a persistent backend workflow using the Symfony database and an explicit user authentication system.","title":"Goal Description"},{"location":"Training-Portal/implementation_plan_authentication%20and%20leaderboard/#proposed-changes","text":"","title":"Proposed Changes"},{"location":"Training-Portal/implementation_plan_authentication%20and%20leaderboard/#1-user-authentication-system","text":"We will implement a standard Symfony authentication flow. - Ensure the User entity implements UserInterface and PasswordAuthenticatedUserInterface . - Configure config/packages/security.yaml with a JSON login route (for the apps to hit) and an interactive web login route (for a future frontend portal). - Add controllers for Registration and Login.","title":"1. User Authentication System"},{"location":"Training-Portal/implementation_plan_authentication%20and%20leaderboard/#2-api-endpoints-for-progress-tracking","text":"Since API Platform is already installed and #[ApiResource] is present on App and UserProgress , we will leverage it instead of writing custom controllers from scratch. - [MODIFY] src/Entity/UserProgress.php and src/Entity/CompletedStep.php : Ensure they are mapped correctly so the frontend can POST and GET progress via the standard /api/user_progresses routes. - [MODIFY] Configure API Platform to automatically link the currently logged-in user to the progress records they create (using a custom DataPersister or StateProcessor). - [MODIFY] public/package-pro/app.js and public/dns-detective/app.js : Remove localStorage reliance. Update the saveProgress() and loadProgress() functions to make fetch() calls to the API Platform endpoints ( /api/user_progresses ).","title":"2. API Endpoints for Progress Tracking"},{"location":"Training-Portal/implementation_plan_authentication%20and%20leaderboard/#3-leaderboard-implementation","text":"We will create a query to aggregate XP across all apps and display it. - [NEW] src/Controller/Api/LeaderboardController.php : - GET /api/leaderboard : Returns a JSON array of the top 10/20 users ranked by total XP across all connected App entities. - [MODIFY] Add a \"Leaderboard\" modal or section to the frontend applications (or a central portal homepage) that fetches and displays this data.","title":"3. Leaderboard Implementation"},{"location":"Training-Portal/implementation_plan_authentication%20and%20leaderboard/#verification-plan","text":"","title":"Verification Plan"},{"location":"Training-Portal/implementation_plan_authentication%20and%20leaderboard/#automatedmanual-verification","text":"Create a dummy test user via the Symfony console or API. Log into the DNS Detective frontend using those credentials. Complete Case #1. Verify via the API and EasyAdmin Dashboard that a UserProgress row was created and updated correctly in the database. Refresh the page to verify that loadProgress() successfully fetches the state from the backend rather than local storage. Hit the /api/leaderboard endpoint to confirm the user's XP is correctly aggregated and ranked.","title":"Automated/Manual Verification"}]}